% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/nongemDat.R
\name{nongemData}
\alias{nongemData}
\alias{nongemData_inSample}
\alias{nongemData_outSample}
\title{Simulating data set under nonGem scenario}
\usage{
nongemData_inSample(n, co, r, beta, inter)

nongemData_outSample(n, co, r, beta, inter)
}
\arguments{
\item{n}{A scalar indicating the number of observation for each treatment group}

\item{co}{A matrix of covariance structure for the predictors, if there is m predictors,
this should be of dimension m by m, symmetric and positive definite.}

\item{r}{A scalar indicating the proportion of explained variance \eqn{R^2} for each treatment group}

\item{beta}{A list of length 2 recording the coefficients of the predictors for those two treatment groups respectively}

\item{inter}{A vector of length 2 recording the intercept term for those two treatment groups respectively}
}
\value{
Output of these two functions for the data generator under nonGem case is not the same,
and you can find explanation for each of them in the following:

For the function \code{nongemData_inSample}
\enumerate{
		\item \code{dat} A dat set with the first column as treatment group index, the second
		column as response and the remaining columns as the predictors design matrix
		\item \code{nu_true_alpha} Theoretical alpha value under numerator method
		\item \code{de_true_alpha} Theoretical alpha value under denominator method
		\item \code{F_true_alpha} Theoretical alpha value under F statistics method
		\item \code{preset_co} The covariance matrix that used for simulating the data, mainly for reference
		\item \code{beta} The beta coeffcients that used for simulating the data, mainly for reference
}

For the function \code{nongemData_outSample}
\enumerate{
		\item \code{y0} Response for each observation under the first treatment assignment
		\item \code{y1} Response for each observation under the second treatment assignment
		\item \code{X} Design matrix for the predictors
		\item \code{optTrt} Optimal treatment assignment, for example, if for certain observation \code{y0>y1},
		then the first treatment assignment is optimal
		\item \code{oracle} Average of the response if every observation take the optimal treatment assignment
		\item \code{oracle2} Average of the response if every observation not to take the optimal treatment assignment
}
}
\description{
These are two functions for simulating data set under nonGem scenario.
}
\details{
These are two functions for simulating data set under nonGem scenario, for both
in-sample and out-sample types respectively. The data is simulated as a linear combination of
certain predictors, which are multivariate Guassian distributed and have preset coefficients as the
functions' argument. Since they are designed for simulating data to test with calculting gem,
those data generators take the simplest setting for two treatment groups with same number
of observations and same proportion of explained variance \eqn{R^2}.

The \code{nongemData_inSample} will generate only one reponse for each observation under certain treatment
group, while \code{nongemData_outSample} will generate two responses under both of the treatments. In general
\code{nongemData_inSample} is used to simulate a sample data to train the gem algorithm and \code{nongemData_outSample}
is used for simulating the population.

As the gem algorithm is based on the linear model coefficients and the number of subjects
in each treatment group, see\url{http://en.wikipedia.org/wiki/Integer_overflow},
the function \code{gemData_inSample} calculates the theoretical value of the alpha under three gem methods.
}
\examples{
bet <- vector("list",2)
bet[[1]] <- c(1,1,1,1,1)
bet[[2]] <- c(1,2,3,4,5)
co <- matrix(0.2,5,5)
diag(co) <- 1
popu1 <- nongemData_inSample(200,co,0.1,bet,c(0,1))
popu2 <- nongemData_outSample(20000,co,0.2,bet,c(0,1))
}

